%%This is a very basic article template.
%%There is just one section and two subsections.
%--------------------------------------------------
  \documentclass[letterpaper]{report}    
%--------------------------------------------------
  %Packeges 
%--------------------------------------------------
  \usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsfonts} % Typical maths resource packages
\usepackage[dvips]{graphicx}
\usepackage{color}                    % For creating coloured text and background
\usepackage{fancyhdr}                 % For inclusion of title at the top of the page
\usepackage[left=3cm,right=1.5 cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage[explicit]{titlesec}
\usepackage{setspace}
\usepackage{pdfpages}
\usepackage{cite}
\usepackage{float}
\usepackage{newclude}
\usepackage{bookmark}
\usepackage{listings}
\usepackage{tikz}
\usepackage{type1cm}
\usepackage{hyperref}                  % For creating hyperlinks in cross

\usetikzlibrary{fit}

\definecolor{grey}{rgb}{0.97,0.97,0.97}
\definecolor{rred}{rgb}{0.6,0,0} % for strings
\definecolor{rgreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{rpurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{rblue}{rgb}{0.25,0.35,0.75} % docs
\newcommand*\chapterlabel{}
\makeatletter
\def\@makechapterhead#1{%
\vspace*{10\p@}%
{\parindent \z@ \centering \reset@font
  \par\nobreak
  \vspace*{2\p@}%
  {\Huge \bfseries \thechapter\quad #1\par\nobreak}
    \par\nobreak
    \vspace*{2\p@}%
    \vskip 40\p@
      %\vskip 100\p@
  }}
\def\@makeschapterhead#1{%
\vspace*{10\p@}%
{\parindent \z@ \centering \reset@font
  \par\nobreak
  \vspace*{2\p@}%
  {\Huge \bfseries #1\par\nobreak}
    \par\nobreak
    \vspace*{2\p@}%
    \vskip 100\p@
      %\vskip 100\p@
  }}
\makeatother
\newcounter{N}
\setlength{\parindent}{0ex}
\setlength{\parskip}{1em}

\lstset{language=JAVA,
basicstyle=\footnotesize\ttfamily,
basewidth=0.5em,
keywordstyle=\color{rpurple}\bfseries,
stringstyle=\color{rred},
commentstyle=\color{rgreen},
morecomment=[s][\color{rblue}]{/**}{*/},
numbers=none,
numberstyle=\tiny\color{black},
stepnumber=2, 
numbersep=10pt,
tabsize=4,
aboveskip=3mm,
belowskip=3mm,
backgroundcolor=\color{grey},
frame=none,
showspaces=false,
showstringspaces=false,
breaklines=true}

\usepackage{Sweave}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace{5cm}
{\href{https://www.portfolioeffect.com}{www.portfolioeffect.com} \\ High
  Frequency Portfolio Analytics\\}
\vspace{8cm}
{\Large \bfseries User Manual \\}
\vspace{0.3cm}
{\Huge\bfseries PortfolioEffectHFT Package \\ for Java\\ }
% ----------------------------------------------------------------
  \vspace{1.5cm}
{Oleg Nechaev \\ oleg.nechaev@portfolioeffect.com} \\[14pt]
% ----------------------------------------------------------------
  \vfill
\emph{{Released Under GPL-3 License\\ by Snowfall Systems,
  Inc.}}\\[2cm]
{2016}
\end{center}
\end{titlepage}

\bookmarksetup{startatroot}
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Contents}
\bibliographystyle{amsplain}%}
\renewcommand{\bibname}{Contents}
\tableofcontents
%\VignetteIndexEntry{PorfolioEffectHFT package}

%\input{manual-concordance}

\chapter{Package Installation}
  
  \section{Building from Source}
Stable builds are in the You need to have Maven installed to build the jar from source. After that in the folder with pom.xml run:
    \begin{lstlisting}
    mvn package
      \end{lstlisting}


\chapter{API Credentials}
All portfolio computations are performed on PortfolioEffect cloud servers.
To obtain a free non-professional account, you need to follow a quick sign-up
process on our website:
  \href{https://www.portfolioeffect.com/registration}{www.portfolioeffect.com/registration}.\par
Please use a valid sign-up address - it will be used to email your
account activation link.

\section{Locate API Credentials} 
Log in to you account and locate your API credentials on the main page

\section{Set API Credentials in Java} 
Run the following commands to set your account API credentials for the PortfolioEffectHFT Java Library.

\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Util;
Util.util_setCredentials("API Username", "API Password", "API Key");
\end{lstlisting}
Credentials are not stored between sessions. You would need to repeat this procedure every time you start a new JVM session or if you changed your account password.\\

You are now ready to call PortfolioEffectHFT methods.




\chapter{Portfolio Construction}
\section{User Data}
Users may supply their own historical datasets for index and position entries. 
This external data could be one a OHLC bar column element (e.g. 1-second close prices) or a vector of actual transaction prices that contains non-equidistant data points. 
You might want to prepend at least N =(4 x windowLength) data points to the
beginning of the interval of interest which would be used for initial calibration of portfolio metrics.
Times expressed in milliseconds from 1970-01-01 00:00:00 EST.

\begin{lstlisting}
long[] indexTime = new[]{1409666400000L, 1409668200000L, 1409670000000L, 1409671800000L, 1409673600000L, 1409675400000L, 1409677200000L, 1409679000000L, 1409680800000L, 1409682600000L, 1409684400000L, 1409686200000L, 1409688000000L};
double[] indexPrice = new[]{102.99, 103.60, 103.65, 103.58, 103.30, 103.52, 103.34, 103.27, 103.45, 103.32, 103.20, 103.25, 103.30};
\end{lstlisting}

\section{Server Data}
At PortfolioEffect we are capturing and storing 1-second intraday bar history for a 
\href{https://www.portfolioeffect.com/docs/symbology}{all NASDAQ traded equites}.
This server-side dataset spans from January 2013 to the latest trading time minus five minutes. 
It could be used to construct asset portfolios and compute intraday portfolio metrics.

\subsection{Create Portfolio}
%Method
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/general-functions/portfolio-create}{Portfolio()}.

\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Portfolio;
...
long[] indexTime;
double[] indexPrice;
...
//Creates new empty Portfolio using user data for index
Portfolio portfolio = new Portfolio(indxePrice, indexTime);
\end{lstlisting}
%Method
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/general-functions/portfolio-create}{Portfolio()}
%creates new asset portfolio or overwrites an existing portfolio object with the
%same name. \par
When using server-side data, it only requires a time interval that would be
treated as a default position holding period unless positions are added with rebalancing.
Index symbol could be specified as well with a default value of ``SPY'' - SPDR
S\&P 500 ETF Trust.
\par
Interval boundaries are passed in the following format:
  \begin{itemize} 
\item ``yyyy-MM-dd HH:MM:SS'' (e.g. ``2014-10-01 09:30:00'')
\item ``yyyy-MM-dd'' (e.g. ``2014-10-01'')
\item ``t-N'' (e.g. ``t-5'' is latest trading time minus 5 days)
\item UTC timestamp in milliseconds (mills from ``1970-01-01 00:00:00'') in EST
time zone
\end{itemize}
\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Portfolio;
...
//Creates new empty Portfolio using server data for index
//Timestamp in "yyyy-MM-dd HH:MM:SS" format
Portfolio portfolio= new Portfolio("2014-10-01 09:30:00", "2014-10-02 16:00:00");
...
//Creates new empty Portfolio using server data for index
// Timestamp in "yyyy-MM-dd" format
Portfolio portfolio= new Portfolio("2014-10-01", "2014-10-02");
...
//Creates new empty Portfolio using server data for index
//Timestamp in "t-N" format
Portfolio portfolio= new Portfolio("t-5", "t");
...
//Timestamp in "t-N" format
//Creates new empty Portfolio using server data for index
//Explicitly specify the symbol for the index 
Portfolio portfolio= new Portfolio("t-5", "t","SPY");
\end{lstlisting}



\subsection {Add Positions}
Positions are added by calling
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/general-functions/portfolio-add-position}{position\_add()}
position\_add() method on a portfolio object
with prices and times  in the same format as index data.
For positions that were rebalanced or had non-default holding periods a 'time' argument could be used to specify rebalancing timestamps.
\begin{lstlisting}
...
import com.portfolioeffect.quant.client.api.Position;
...
long[] priceTime;
double[] price;
...
//Single position without rebalancing with 100 assets for user data
Position positionGOOG = portfolio.add_position("GOOG", 100, priceTime, time);
...
//Single position without rebalancing with 100 assets for server data
Position positionGOOG = portfolio.add_position("GOOG", 100);
...
...
long[] priceTime;
double[] price;
int[] quantity;
long[] quantityTime;
...
//Single position with rebalancing for user data
Position positionGOOG =  portfolio.add_position("GOOG",  quantity,  quantityTime,  price, priceTime);
...
//Single position with rebalancing for server data
Position positionGOOG =  portfolio.add_position("GOOG",  quantity,  quantityTime);
...
...
int[] quantity= new int[]{300,150}
String[] quantityTimeString= new String[]{"2014-09-01 09:40:00","2014-09-07 14:30:00"}
//Single position with rebalancing for server data
Position positionGOOG =  portfolio.add_position("GOOG",  quantity,  quantityTimeString);
\end{lstlisting}


\subsection {Get Symbols List}
Once portfolio is created, 
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/general-functions/portfolio-available-symbols}{portfolio\_availableSymbols()} 
symbols\_available()
method could be called to receive the list of all available symbols for position creation. 
Each symbol is accompanied by a full company/instrument description and listing exchange name.

\begin{lstlisting}
//list.get(0) Contains array of  symbols name (id)
//list.get(1) Contains array of exchanges 
//list.get(2) Contains array of descriptions
List<String[]> list = portfolio.symbols_available()


 id      description                                                 exchange  
"BBC"   "BioShares Biotechnology Clinical Trials Fund"              "NASDAQ"  
"SCS"   "Steelcase Inc. Common Stock"                               "NYSE"    
"BBD"   "Banco Bradesco Sa American Depositary Shares"              "NYSE"    
"BBG"   "Bill Barrett Corporation Common Stock"                     "NYSE"    
"STPP"  "Barclays PLC - iPath US Treasury Steepener ETN"            "NASDAQ"  
"BBF"   "BlackRock Municipal Income Investment Trust"               "NYSE"      
"BBH"   "Market Vectors Biotech ETF"                                "NYSEARCA"
"SCON"  "Superconductor Technologies Inc. - Common Stock"           "NASDAQ"  
"SCX"   "L.S. Starrett Company (The) Common Stock"                  "NYSE"    
"BBK"   "Blackrock Municipal Bond Trust"                            "NYSE"  
\end{lstlisting}

\chapter{Metrics}
\section{Class Metric}
The result of the calculation a portfolio or positional metric stored in the  object of Metric class.
Methods of this class allows  to receive data set and check for errors that may have been during the calculation.
\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Portfolio;
import com.portfolioeffect.quant.client.api.Position;
import com.portfolioeffect.quant.client.api.Metric;
import com.portfolioeffect.quant.client.model.ComputeErrorException;
...

//Timestamp in "t-N" format
//Creates new empty Portfolio using server data for index
//Explicitly specify the symbol for the index 
Portfolio portfolio= new Portfolio("t-5", "t","SPY");

//Add  position without rebalancing with 100 assets for server data
Position positionGOOG = portfolio.add_position("GOOG", 100);
//Add  position without rebalancing with 100 assets for server data
Position positionAAPL = portfolio.add_position("AAPL", 100);

//Create  object of Metric class  containing variance of portfolio
Metric variancePortfolio = portfolio.variance();

//Create  object of Metric class  containing variance of GOOG position 
Metric varianceGOOG = positionGOOG.variance();

//Check for errors in the calculation of variancePortfolio
if( variancePortfolio.hasError() ){
	//get error message 
	String errorMsg = variance.getError()
	...
}


...
//Another method for check for errors
try {
	double[] t = variance.getValue();
} catch (ComputeErrorException e) {
	//get error message 
	String errorMsg = variance.getError();
	...
}
		
...

//Get array of  portfolio variance values.
double[] variancePortfolioValue = variancePortfolio.getValue();

//Get the timestamps corresponding to the values in variancePortfolioValue
//Times expressed in milliseconds from 1970-01-01 00:00:00 EST
long[] variancePortfolioTime = variancePortfolio.getTime();

//Get last value of portfolio variance array
//This is equivalent to  variancePortfolioValue[ variancePortfolioValue.length -1]
double variancePortfolioLastValue = variancePortfolio.getLastValue();

//Get last value of variance timestamp array
//This is equivalent to  variancePortfolioTime[ variancePortfolioTime.length -1]
long variancePortfolioLastTime = variancePortfolio.getLastTime();



...
//Another method for check for errors
double[] variancePortfolioValue;
long[] variancePortfolioTime;
try {
	variancePortfolioValue = variancePortfolio.getValue();
	variancePortfolioTime = variancePortfolio.getTime();
} catch (ComputeErrorException e) {
	//get error message 
	String errorMsg = variance.getError();
	...
}


\end{lstlisting}

\section{List of a the available Portfolio and Position methods for calculation of metrics}
  \begin{description} 

\item["alpha\_exante()"] \hfill \\ 
Creates  (ex-ante) according to the Single Index Model.


\item["alpha\_jensens()"] \hfill \\ 
Creates  Jensen's alpha (excess return) according to the Single
 Index Model.


\item["beta()"] \hfill \\ 
Creates  beta (market sensitivity) according to the Single Index
 Model.


\item["calmar\_ratio()"] \hfill \\ 
Creates Calmar ratio (cumulative return to maximum drawdown) of a
 portfolio


\item["cumulant(int order)"] \hfill \\ 
Creates N-th cumulant of  return distribution.


\item["down\_capture\_ratio()"] \hfill \\ 
Creates down capture ratio.


\item["down\_number\_ratio()"] \hfill \\ 
Creates down number rati.


\item["down\_percentage\_ratio()"] \hfill \\ 
Creates down percentage ratio of  returns.


\item["downside\_variance (double thresholdReturn) "] \hfill \\ 
Creates downside variance of  returns.


\item["expected\_downside\_return (double thresholdReturn) "] \hfill \\ 
Creates  cumulative expected return below a certain threshold.


\item["expected\_return()"] \hfill \\ 
Creates cumulative expected return.


\item["expected\_shortfall (double confidenceInterval) "] \hfill \\ 
Creates  conditional Value-at-Risk (Expected Tail Loss) at a
 given confidence interval.


\item["expected\_upside\_return (double thresholdReturn) "] \hfill \\ 
Creates  cumulative expected return above a certain threshold.


\item["fractal\_dimension()"] \hfill \\ 
Creates portfolio fractal dimension.
Portfolio  fractal dimension  is  a weighted sum of fractal
 dimensions of its position returns.


\item["gain\_loss\_variance\_ratio()"] \hfill \\ 
Creates gain to loss variance ratio of returns.


\item["gain\_variance()"] \hfill \\ 
Creates gain variance of returns.


\item[" hurst\_exponent()"] \hfill \\ 
Creates  Hurst exponent of returns.
Portfolio Hurst exponent is a weighted sum of the Hurst exponents
 of its position returns.


\item["information\_ratio()"] \hfill \\ 
Creates information ratio.


\item["kurtosis()"] \hfill \\ 
Creates kurtosis of returns.


\item["log\_return()"] \hfill \\ 
Creates log\_return from the beginning of the holding period.


\item["loss\_variance()"] \hfill \\ 
Creates loss variance of returns.


\item["max\_drawdown()"] \hfill \\ 
Creates Creates maximum drawdown of preturns.


\item["mod\_sharpe\_ratio (double confidenceInterval) "] \hfill \\ 
Creates modified Sharpe ratio  at a given confidence
 interval.


\item["moment (int order) "] \hfill \\ 
Creates N-th order central moment of  return distribution.


\item["omega\_ratio (double thresholdReturn) "] \hfill \\ 
Creates Omega Ratio.


\item["profit()"] \hfill \\ 
Creates profit.


\item["rachev\_ratio (double confidenceIntervalA,
            double confidenceIntervalB) "] \hfill \\ 
Creates Rachev ratio  at given confidence intervals.



\item["sharpe\_ratio()"] \hfill \\ 
Creates Sharpe Ratio.


\item["skewness()"] \hfill \\ 
Creates skewness of  returns.


\item["sortino\_ratio (double thresholdReturn) "] \hfill \\ 
Creates Sortino ratio.


\item["starr\_ratio (double confidenceInterval) "] \hfill \\ 
Creates Stable Tail Adjusted Return Ratio (STARR)  
at given confidence intervals.

\item["treynor\_ratio()"] \hfill \\ 
Creates Treynor Ratio.


\item["txn\_costs()"] \hfill \\ 
Creates monetary value of accumulated transactional costs.


\item["up\_capture\_ratio()"] \hfill \\ 
Creates up capture ratio.


\item["up\_number\_ratio()"] \hfill \\ 
Creates up number ratio.


\item["up\_percentage\_ratio()"] \hfill \\ 
Creates up percentage ratio.


\item["upside\_downside\_variance\_ratio (double thresholdReturn) "] \hfill \\ 
Creates upside to downside variance ratio.


\item["upside\_variance (double thresholdReturn) "] \hfill \\ 
Creates upside variance of returns.


\item["value\_at\_risk (double confidenceInterval) "] \hfill \\ 
Creates portfolio Value-at-Risk at a given confidence interval.


\item["value()"] \hfill \\ 
Creates monetary value  from the beginning of the holding
 period.


\item["variance()"] \hfill \\ 
Creates variance of  returns.
 \end{description} 
 
 
 \section{List of a the available Position class specific  methods for calculation of metrics}
 
 \begin{description} 
\item[" quantity()"] \hfill \\ 
  Creates total number of shares associated with the given position

\item["price()"] \hfill \\ 
Creates position price


\item["weight()"] \hfill \\ 
Creates ratio of a monetary position value to the monetary value of the
whole portfolio. Expressed in decimal points of portfolio value.

\item["return\_autocovariance(int lag)"] \hfill \\ 
Creates autocovariance of position returns for a certain time lag in sec.


\item["correlation(Position positionB)"] \hfill \\ 
Creates correlation between current position and positionB.


\item["covariance(Position positionB)"] \hfill \\ 
Creates covariance between current position and positionB.

 \end{description} 	

\section{Tips and tricks for metric calculation }
It should be noted that the request to the server does not take place in time of creation Metric object, but in the moment of query calculation result(call such method as getValue(), hasError(), ...).

To  save computing time, try to unite Metric creation in groups.
In this case it will generate batch request to the server.
In during batch request some server calculation is  not be repeated compare with number single requests.
It has to do with the metrics belonging the same portfolio
or positions  metrics of this portfolio.

\begin{lstlisting}
...
Portfolio portfolio= new Portfolio("t-5", "t","SPY");
Position positionGOOG = portfolio.add_position("GOOG", 100);
Position positionAAPL = portfolio.add_position("AAPL", 100);



//use this style
Metric variancePortfolio = portfolio.variance();
Metric varianceGOOG = positionGOOG.variance();
Metric varianceAAPL = positionAAPL.variance();
double[] variancePortfolioValue = variancePortfolio.getValue();//one request to server in this moment, it will be calculated variancePortfolio, varianceGOOG and varianceAAPL
double[] varianceGOOGValue = variancePortfolio.getValue();
long[] variancePortfolioTime = variancePortfolio.getTime();


//instead this
Metric variancePortfolio = portfolio.variance();
double[] variancePortfolioValue = variancePortfolio.getValue();//request to server
long[] variancePortfolioTime = variancePortfolio.getTime();
Metric varianceGOOG = positionGOOG.variance();
double[] varianceGOOGValue = variancePortfolio.getValue();//request to server
Metric varianceAAPL = positionAAPL.variance();

\end{lstlisting}


\chapter{Portfolio Settings}
Assignment portfolio settings is done using method settings(String key, String value).
\section{Portfolio Metrics}
These settings regulate how portfolio returns and return moments are computed
\subsection {Portfolio Metrics Mode}
One of the two modes for collecting portfolio metrics that could be used:
  \begin{itemize} 					
\item ``portfolio''- portfolio metrics are computed using previous history of position rebalancing.
Portfolio risk and performance metrics account for the periods with no
market exposure (i.e. when no positions are held) depending on the
holding periods accounting settings (see holding periods mode below).
\item ``price'' -    at any given point of time, both position and portfolio
metrics are computed for a buy-and-hold strategy. 
This mode is a common for classic portfolio theory and is often used in
academic literature for portfolio optimization or when computing price
statistics.
\end{itemize}
By default, mode is set to "portfolio".
\begin{lstlisting}

// set "price" mode
portfolio.settings("portfolioMetricsMode", "price");

//set "portfolio" mode
portfolio.settings("portfolioMetricsMode", "portfolio");
\end{lstlisting}

\subsection {Holding Periods Only}
This setting should only be used when portfolio metrics mode is set to "portfolio".
When holdingPeriodsOnly is set to "false", trading strategy risk and performance
metrics will be annualized to include time intervals when strategy had no market exposure at certain points (i.e. when position quantity were zero).
When set to "true", trading strategy metrics are annualized only based on actual holding intervals.

\begin{lstlisting}
// enable holdingPeriodsOnly
portfolio.settings("holdingPeriodsOnly","true");

// disable holdingPeriodsOnly
portfolio.settings("holdingPeriodsOnly","false");

\end{lstlisting}

\subsection {Short Sales Mode}
This setting is used to specify how position weights are computed. Available modes are:
  \begin{itemize} 
\item  ``lintner'' - the sum of absolute weights is equal to 1 (Lintner
                                                                assumption)
\item ``markowitz'' - the sum of weights must equal to 1 (Markowitz
                                                          assumption)
\end{itemize}
Defaults to "lintner", which implies that the sum of absolute weights is used to normalize investment weights.

\begin{lstlisting}

// weights are normalized based on a simple sum (Markowitz)
portfolio.settings("shortSalesMode","markowitz");


// weights are normalized based on a sum of absolute values (Lintner)
portfolio.settings("shortSalesMode","lintner");

\end{lstlisting}

\section{Data Sampling}
These settings regulate how results of portfolio computations are returned. 
Depending on your usage scenario, some of them might bring significantly improvement to speed of your portfolio computations
\subsection{Results Sampling Interval}
Interval to be used for sampling computed results before returning them to the caller. 
Available interval values are: 
  \begin{itemize} 
\item ``Xs'' - seconds
\item ``Xm'' - minutes
\item ``Xh'' - hours
\item ``Xd'' - trading days (6.5 hours in a trading day)
\item ``Xw'' - weeks (5 trading days in 1 week)
\item ``Xmo'' - month (21 trading day in 1 month)
\item ``Xy'' - years (256 trading days in 1 year)
\item ``none'' - no sampling.
\item ``last'' - only the very last data point is returned  
\end{itemize}
Large sampling interval would produce smaller vector of results and would require less time spent on data transfer. 
Default value of ``1s'' indicates that data is returned for every second during
trading hours.
\begin{lstlisting}


// sample results every 30 seconds
portfolio.settings("resultsSamplingInterval","30s");
variance_30s=portfolio.variance();

// sample results every 5 minutes
portfolio.settings("resultsSamplingInterval","30s");

\end{lstlisting}
\subsection{Input Sampling Interval}
Interval to be used as a minimum step for sampling input prices. Available interval values are: 
  \begin{itemize} 
\item ``Xs'' - seconds
\item ``Xm'' - minutes
\item ``Xh'' - hours
\item ``Xd'' - trading days (6.5 hours in a trading day)
\item ``Xw'' - weeks (5 trading days in 1 week)
\item ``Xmo'' - month (21 trading day in 1 month)
\item ``Xy'' - years (256 trading days in 1 year)
\item ``none'' - no sampling
\end{itemize}
Default value is ``none'', which indicates that no sampling is applied.
\begin{lstlisting}


// sample input prices every 30 seconds
portfolio.settings("inputSamplingInterval","30s");


//sample input prices every 5 min
portfolio.settings("inputSamplingInterval","5m");
variance_5m=portfolio.variance();

\end{lstlisting}


\section{Model Pipeline}
\subsection{Window Length}
Specifies rolling window length that should be used for computing portfolio and position metrics. 
When portfolio mode is set to ``portfolio'', it is also the length of rebalancing history window to be used.
Available interval values are:
  \begin{itemize} 
\item ``Xs'' - seconds
\item ``Xm'' - minutes
\item ``Xh'' - hours
\item ``Xd'' - trading days (6.5 calendar hours in a trading day)
\item ``Xw'' - weeks (5 trading days in 1 week)
\item ``Xmo'' - month (21 trading day in 1 month)
\item ``Xy'' - years (256 trading days in 1 year)
\item ``all'' - all observations are used
\end{itemize}
Default value is ``1d'' - one trading day.
\begin{lstlisting}

// 1 hour rolling window
portfolio.settings("windowLength","1h");


// 1 week rolling window
portfolio.settings("windowLength","1d");

\end{lstlisting}

\subsection{Time Scale}
Interval to be used for scaling return distribution statistics and producing metrics forecasts at different horizons. Available interval values are: 
  \begin{itemize} 
\item ``Xs'' - seconds
\item ``Xm'' - minutes
\item ``Xh'' - hours
\item ``Xd'' - trading days (6.5 hours in a trading day)
\item ``Xw'' - weeks (5 trading days in 1 week)
\item ``Xmo'' - month (21 trading day in 1 month)
\item ``Xy'' - years (256 trading days in 1 year)
\item ``all'' - actual interval specified during portfolio creation.
\end{itemize}
Default value is "1d" - one trading day.
\begin{lstlisting}


// 1 hour time scale 
portfolio.settings("timeScale","1h");

// 1 day time scale
portfolio.settings("timeScale","1d");

\end{lstlisting}

\subsection{Microstructure Noise Model}
Enables market microstructure noise model of distribution returns.\\
Defaults to 'true', which means that microstructure effects are modeled and resulting HF noise is removed from metric calculations. 
When 'false', HF microstructure noise is not separated from asset returns, which at high trading frequencies could yield noise-contaminated results.

\begin{lstlisting}


// HF noise model is enabled
portfolio.settings("noiseModel","true");

// HF noise model is disabled
portfolio.settings("noiseModel","false");

\end{lstlisting}

\subsection{Jumps/Outliers Model}
Used to select jump filtering mode when computing return statistics. Available modes are: 
  \begin{itemize} 
\item ``none'' - price jumps are not filtered anywhere
\item ``moments'' - price jumps are filtered only when computing return moments
(i.e. for expected return, variance, skewness, kurtosis and derived
metrics)
\item ``all'' - price jumps are filtered from computed returns, prices and all
return metrics.
\end{itemize}
\begin{lstlisting}


// Price jumps detection is enabled for returns and moments
portfolio.settings("jumpsModel","all");


// Price jumps detection is disabled
portfolio.settings("jumpsModel","none");

\end{lstlisting}

\subsection {Density Model}
Used to select density approximation model of return distribution. Available models are:
  \begin{itemize} 
\item ``GLD'' - Generalized Lambda Distribution
\item ``CORNER\_FISHER'' - Corner-Fisher approximation
\item ``NORMAL'' - Gaussian distribution
\end{itemize}
Defaults to ``GLD'', which would fit a very broad range of distribution shapes.

\begin{lstlisting}

// Using normal density
portfolio.settings("densityModel","NORMAL");

// Using Generalized Lambda density
portfolio.settings("densityModel","GLD");

\end{lstlisting}

\subsection {Factor Model}
Factor model to be used when computing portfolio metrics. Available models are: 
  \begin{itemize} 
\item ``sim'' - portfolio metrics are computed using the Single Index Model
\item ``direct'' - portfolio metrics are computed using portfolio value itself
(experimental)
\end{itemize}
Defaults to "sim", which implies that the Single Index Model is used to compute portfolio metrics.

\begin{lstlisting}

// Single Index Model is used
portfolio.settings("factorModel","sim");

// Direct model is used
portfolio.settings("factorModel","direct");

\end{lstlisting}


\subsection {Fractal Price Model}
Used to enable mono-fractal price assumptions (fGBM) when time scaling return moments.  
Defaults to 'true', which implies that computed Hurst exponent is used to scale return moments. 
When 'false', price is assumed to follow regular GBM with Hurst exponent = 0.5.

\begin{lstlisting}


// Fractal price model is enabled
portfolio.settings("fractalPriceModel","true");
variance_fractal=portfolio.variance();

// Fractal price model is disabled
portfolio.settings("fractalPriceModel","false");

\end{lstlisting}


\subsection{Drift Term}
Used to enable drift term (expected return) when computing probability density approximation and related metrics (e.g. CVaR, Omega Ratio, etc.).
Defaults to 'false', which implies that distribution is centered around expected return.

\begin{lstlisting}


// Drift term is enabled
portfolio.settings("driftTerm","true");


// Drift term is disabled
portfolio.settings("driftTerm", "false");


\end{lstlisting}

\section{Transactional Costs}
These settings provide a framework for adding variable and fixed transactional costs into return, expected return and profit calculations.
All metrics based on expected return like Sharpe Ratio, VaR (with drift term enabled) would reflect transactional costs in their computations.
\subsection{Cost Per Share}
Amount of transaction costs per share. Default value is 0.
\begin{lstlisting}


// Transactional costs per share are 0.5 cent 
portfolio.settings("txnCostPerShare","0.005");

// Transactional costs per share are 0.1 cent 
portfolio.settings("txnCostPerShare","0.001");

\end{lstlisting}
\subsection {Cost Per Transaction}
Amount of fixed costs per transaction. Defaults to 0.
\begin{lstlisting}
                                          "2014-10-02 11:30:00"])

// Fixed costs per transaction are 9 dollars
portfolio.settings("txnCostFixed","9.0");

// Fixed costs per transaction are 1 dollar
portfolio.settings("txnCostFixed","1.0");


\end{lstlisting}


\chapter{Portfolio Optimization}

\section{Optimization Goals \& Constraints}
A classic problem of constructing a portfolio that meets certain maximization/minimization 
goals and constraints is addressed in our version of a multi-start portfolio optimization algorithm. At every time step
optimization algorithm tries to find position weights that best meet optimization goals and constraints.

\subsection{Key Features}
\begin{itemize} 
\item A multi-start approach is used to compare local optima with each other and select a global optimum. 
Local optima are computed using a modified Hooke-Jeeves  method.
\item When optimization algorithm is supplied with mutually exclusive constraints, it would try to produce result that is equally close (in absolute terms) to all constraint boundaries. 
For instance, constraints ``x > 6'' and ``x < 4'' are mutually exclusive, so
the optimization algorithm would choose ``x = 5'', which is a value that has the smallest distance to both constraints.
\item Portfolio metrics change over time, but optimization uses only the latest value in the time series.
Therefore, the faster metric series would change, the more likely current optimal weights would deviate
from the optimal weights at the next time step. 
\item Optimization results depend on provided portfolio settings. 
For example, short windowLength would produce "spot" versions of portfolio metrics and 
computed optimal weights would change faster to reflect shortened metric horizon. 
\end{itemize}

\subsection{Optimization Goals}
Optimization algorithm requires a single maximization/minimization goal to be set using 
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/optimization-functions/optimization-goal}{optimization\_goal()}
constructor of Optimizer class; 
%(see\href{https://www.portfolioeffect.com/docs/platform/quant/manuals/portfolio-construction}{portfolio construction}).
created Optimizer object could be used to add optional optimization costraints and then call 
%\href{https://www.portfolioeffect.com/docs/platform/quant/functions/optimization-functions/optimization-run}
optimization\_run()
method to launch portfolio optimization.

\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Metric;
import com.portfolioeffect.quant.client.api.Optimizer;
import com.portfolioeffect.quant.client.api.Portfolio;
import com.portfolioeffect.quant.client.api.Position;
...
Portfolio portfolio=new Portfolio("2014-10-01 09:30:00", "2014-10-02 16:00:00");
Position positionC=portfolio.add_position("C",500);
Position positionGOOG=portfolio.add_position("GOOG",600);	
portfolio.settings("portfolioMetricsMode","price").settings("resultsSamplingInterval","30m");

//created optimizer object, set optimization goal as log_return and optimization direction as maximization
Optimizer optimizer= new Optimizer(portfolio.log_return(),"max");

// launch optimization and obtain appropriate Metric object
Metric optimalPortfolioMeric=optimizer.run();
// get optimal portfolio
Portfolio optimalPortfolio = optimalPortfolioMetric.getPortfolio();
// get a metic of optimal portfolio
Metric optimalReturn = optimalPortfolio.log_return();

\end{lstlisting}


\subsection{Adding Constraints}
Optimization constraints cover both metric-based and weight-based
constraints. Metric-based constraints limit portfolio-level metrics to a certain
range of values. For example, zero beta constraint would produce market-neutral optimal portfolio.
Weight-based constraints operate on optimal position weights or sum of weights to 
give control over position concentration risks or short-sales assumptions.
\par
Constraint methods could be chained to produce complex optimization rules:
  \par
Since position quantities are integer numbers and weights are decimals, a discretization error is introduced while converting optimal position weights to corresponding quantities. 
By default, optimal portfolio starts with a value of the initial portfolio. 
Portfolio value could be fixed to a constant level at every optimization step
(see corresponding constraint below).
Higher portfolio value could be used to keep difference between computed optimal weights and effective weights based on position quantities small.
Lower portfolio value or higher asset price would normally increase discretization error.

\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Metric;
import com.portfolioeffect.quant.client.api.Optimizer;
import com.portfolioeffect.quant.client.api.Portfolio;
import com.portfolioeffect.quant.client.api.Position;
...
Portfolio portfolio=new Portfolio("2014-10-01 09:30:00", "2014-10-02 16:00:00");
Position positionC=portfolio.add_position("C",500);
Position positionGOOG=portfolio.add_position("GOOG",600);	
Position positionMSFT=portfolio.add_position('MSFT',200);	
portfolio.settings("portfolioMetricsMode","price").settings("resultsSamplingInterval","30m");



Optimizer optimizer= new Optimizer(portfolio.variance(),"min");

// add constraints
optimizer.constraint(portfolio.beta(),"<=",1);
optimizer.constraint(positionGOOG.weight(),"=",0.1);

// launch optimization and obtain optimal portfolio
Portfolio optimalPortfolio=optimizer.run().getPortfolio();
\end{lstlisting}

Use portfolio metric "value" to specify the monetary value in US dollars of the optimized portfolio.
This value will be divided between the positions according to the goal and constraints of optimization.

\begin{lstlisting}
import com.portfolioeffect.quant.client.api.Metric;
import com.portfolioeffect.quant.client.api.Optimizer;
import com.portfolioeffect.quant.client.api.Portfolio;
import com.portfolioeffect.quant.client.api.Position;
...
Portfolio portfolio=new Portfolio("2014-10-01 09:30:00", "2014-10-02 16:00:00");
Position positionC=portfolio.add_position("C",500);
Position positionGOOG=portfolio.add_position("GOOG",600);	
Position positionMSFT=portfolio.add_position('MSFT',200);	
portfolio.settings("portfolioMetricsMode","price").settings("resultsSamplingInterval","30m");



Optimizer optimizer= new Optimizer(portfolio.variance(),"min");

//Set the monetary value in US dollars of the optimized portfolio.
optimizer.constraint(portfolio.value(),"=",1e6);


// launch optimization and obtain optimal portfolio
Portfolio optimalPortfolio=optimizer.run().getPortfolio();


\end{lstlisting}


The following portfolio metrics could currently be used as optimization goals or constraints:
 
 \begin{description} 
 
 \item["alpha\_exante()"] \hfill \\ 
Creates  (ex-ante) according to the Single Index Model.
 
 \item["beta()"] \hfill \\ 
\item["alpha\_jensens()"] \hfill \\ 
Creates  Jensen's alpha (excess return) according to the Single
 Index Model.

Creates  beta (market sensitivity) according to the Single Index
 Model.

\item["cumulant(int order)"] \hfill \\ 
		Creates N-th cumulant of  return distribution.

\item["downside\_variance (double thresholdReturn) "] \hfill \\ 
Creates downside variance of  returns.


\item["expected\_return()"] \hfill \\ 
Creates cumulative expected return.

 \item["expected\_upside\_return (double thresholdReturn) "] \hfill \\ 
Creates  cumulative expected return above a certain threshold.

\item["expected\_downside\_return (double thresholdReturn) "] \hfill \\ 
Creates  cumulative expected return below a certain threshold.


\item["expected\_shortfall (double confidenceInterval) "] \hfill \\ 
Creates  conditional Value-at-Risk (Expected Tail Loss) at a
 given confidence interval.

\item["gain\_loss\_variance\_ratio()"] \hfill \\ 
Creates gain to loss variance ratio of returns.

\item["gain\_variance()"] \hfill \\ 
Creates gain variance of returns.

\item["information\_ratio()"] \hfill \\ 
Creates information ratio.




\item["kurtosis()"] \hfill \\ 
Creates kurtosis of returns.



\item["log\_return()"] \hfill \\ 
Creates log\_return from the beginning of the holding period.

\item["loss\_variance()"] \hfill \\ 
Creates loss variance of returns.


\item["mod\_sharpe\_ratio (double confidenceInterval) "] \hfill \\ 
Creates modified Sharpe ratio  at a given confidence
 interval.

\item["moment (int order) "] \hfill \\ 
Creates N-th order central moment of  return distribution.


\item["omega\_ratio (double thresholdReturn) "] \hfill \\ 
Creates Omega Ratio.

\item["rachev\_ratio (double confidenceIntervalA,
 double confidenceIntervalB) "] \hfill \\ 
Creates Rachev ratio  at given confidence intervals.


\item["sharpe\_ratio()"] \hfill \\ 
Creates Sharpe Ratio.

\item["skewness()"] \hfill \\ 
Creates skewness of  returns.

\item["starr\_ratio (double confidenceInterval) "] \hfill \\ 
Creates Stable Tail Adjusted Return Ratio (STARR)  
at given confidence intervals.
		
\item["sortino\_ratio (double thresholdReturn) "] \hfill \\ 
Creates Sortino ratio.
	
\item["treynor\_ratio()"] \hfill \\ 
Creates Treynor Ratio.

\item["upside\_downside\_variance\_ratio (double thresholdReturn) "] \hfill \\ 
Creates upside to downside variance ratio.

\item["upside\_variance (double thresholdReturn) "] \hfill \\ 
Creates upside variance of returns.


\item["value\_at\_risk (double confidenceInterval) "] \hfill \\ 
Creates portfolio Value-at-Risk at a given confidence interval.

\item["variance()"] \hfill \\ 
Creates variance of  returns.



	

The following portfolio metrics could currently be used as optimization goals: 

\begin{description}

\item["constraints\_only()"] \hfill \\ 
The goal of optimization is only to satisfy the all constraints.

\item["equiweight()] \hfill \\  
No optimization is performed and constraints are not processes.
Portfolio positions are returned with equal weights

\end{description}

The following position metric could currently be used as optimization constraint: 
\begin{description}

\item["weight()"] \hfill \\ 
Creates ratio of a monetary position value to the monetary value of the
whole portfolio. Expressed in decimal points of portfolio value.
\end{description}

\end{description}

\end{document}

